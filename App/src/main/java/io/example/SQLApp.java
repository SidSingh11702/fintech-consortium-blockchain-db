/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.example;

import io.grpc.stub.StreamObserver;
import io.ipfs.multihash.Multihash;
import tendermint.abci.Types;
import tendermint.abci.ABCIApplicationGrpc;
import com.google.protobuf.ByteString;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import io.ipfs.api.IPFS;

class SQLApp extends ABCIApplicationGrpc.ABCIApplicationImplBase {
    private Connection conn;
    private IPFS ipfs;

    private String TableName;
//    SCHEMA = [Name varchar(30) NOT NULL, AadharNo char(12) NOT NULL, AadharScanHash varchar(255) NOT NULL, PassportNo varchar(9), PassportScanHash varchar(255)]
//    PRIMARY KEY = AadharNo

    SQLApp(Connection conn, IPFS ipfs) {
        this.conn = conn;
        this.ipfs = ipfs;
        TableName = "KYC";
    }

    private int validate(ByteString tx) {
/*        Logic to be applied by the company */
        String[] s = new String(tx.toByteArray(), StandardCharsets.UTF_8).split("\\s+");
        byte[] aadharScan = null;
        byte[] passportScan = null;

        switch (s[0]) {
            case "ADD":
                // User query -> ADD Name AadharNo AadharHash PassportNo PassportHash
                try {
                    aadharScan = ipfs.cat(Multihash.fromBase58(s[3]));
                    passportScan = ipfs.cat(Multihash.fromBase58(s[5]));

                    FileOutputStream outputStream1 = new FileOutputStream("aadhar.jpg");
                    outputStream1.write(aadharScan);
                    outputStream1.close();

                    FileOutputStream outputStream2 = new FileOutputStream("passport.jpg");
                    outputStream2.write(passportScan);
                    outputStream2.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                break;
            case "UPDATE":
                // User query -> UPDATE AadharNo PassportNo PassportHash
                try {
                    passportScan = ipfs.cat(Multihash.fromBase58(s[3]));

                    FileOutputStream outputStream = new FileOutputStream("passport.jpg");
                    outputStream.write(passportScan);
                    outputStream.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                break;
            case "DELETE":
                // User query -> DELETE AadharNo
                break;
        }

        return 0;
    }

    @Override
    public void checkTx(Types.RequestCheckTx req, StreamObserver<Types.ResponseCheckTx> responseObserver) {
        System.out.println("checkTx called");
        var tx = req.getTx();
        System.out.println(tx);
        int code = validate(tx);
        /*
        If Code != 0, it will be rejected from the mempool and hence not broadcasted to other peers,
        and not included in a proposal block.
        */
        var resp = Types.ResponseCheckTx.newBuilder()
                .setCode(code)
                .setGasWanted(1)
                .build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void beginBlock(Types.RequestBeginBlock req, StreamObserver<Types.ResponseBeginBlock> responseObserver) {
        System.out.println("beginBlock called");
        var resp = Types.ResponseBeginBlock.newBuilder().build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void echo(Types.RequestEcho request, StreamObserver<Types.ResponseEcho> responseObserver) {
        System.out.println("echo called");
        var resp = Types.ResponseEcho.newBuilder().build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void info(Types.RequestInfo request, StreamObserver<Types.ResponseInfo> responseObserver) {
        System.out.println("info called");
        var resp = Types.ResponseInfo.newBuilder()
                .build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void flush(Types.RequestFlush request, StreamObserver<Types.ResponseFlush> responseObserver) {
        System.out.println("flush called");
        var resp = Types.ResponseFlush.newBuilder()
                .build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void initChain(Types.RequestInitChain request, StreamObserver<Types.ResponseInitChain> responseObserver) {
        System.out.println("initChain called");
        var resp = Types.ResponseInitChain.newBuilder().build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void endBlock(Types.RequestEndBlock request, StreamObserver<Types.ResponseEndBlock> responseObserver) {
        System.out.println("endBlock called");
        var resp = Types.ResponseEndBlock.newBuilder().build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void deliverTx(Types.RequestDeliverTx req, StreamObserver<Types.ResponseDeliverTx> responseObserver) {
        System.out.println("deliverTx called");
        var tx = req.getTx();
        int code = validate(tx);
        /*
        If Code != 0, the transaction will be considered invalid, though it is still included in the block.
        */
        if (code == 0) {
            try {
                String s = new String(tx.toByteArray(), StandardCharsets.UTF_8);
                String[] s1 = s.split("\\s+");
                String sqlQuery = null;
                switch (s1[0]) {
                    case "ADD":
                        // User query -> ADD Name AadharNo AadharHash PassportNo PassportHash
                        sqlQuery = "INSERT INTO "+TableName+" VALUES (\""+s1[1]+"\", \""+s1[2]+"\", \""+s1[3]+"\", \""+s1[4]+"\", \""+s1[5]+"\");";
                        break;
                    case "UPDATE":
                        // User query -> UPDATE AadharNo PassportNo PassportHash
                        sqlQuery = "UPDATE "+TableName+" SET PassportNo=\""+s1[2]+"\", PassportScanHash=\""+s1[3]+"\" WHERE AadharNo=\""+s1[1]+"\";";
                        break;
                    case "DELETE":
                        // User query -> DELETE AadharNo
                        sqlQuery = "DELETE FROM "+TableName+" WHERE AadharNo=\""+s1[1]+"\";";
                        break;
                }
                System.out.println(sqlQuery);
                Statement statement = conn.createStatement();
                statement.executeUpdate(sqlQuery);
                statement.close();
            }catch (SQLException e){
                System.out.println(e);
            }
        }
        var resp = Types.ResponseDeliverTx.newBuilder()
                .setCode(code)
                .build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
    public void commit(Types.RequestCommit req, StreamObserver<Types.ResponseCommit> responseObserver) {
        System.out.println("commit called");
        try {
            conn.commit();
        }catch(SQLException e1) {
            System.out.println(e1.getMessage());
            try{
                if(conn != null) {
                    conn.rollback();
                }
            }catch(SQLException e2) {
                System.out.println(e2.getMessage());
            }
        }
        var resp = Types.ResponseCommit.newBuilder()
                .setData(ByteString.copyFrom(new byte[8]))
                .build();
        responseObserver.onNext(resp);
        responseObserver.onCompleted();
    }

    @Override
/*  Query the local node's state. For reads that require consensus, use a transaction. */
    public void query(Types.RequestQuery req, StreamObserver<Types.ResponseQuery> responseObserver) {
        System.out.println("query called");
        var k = req.getData().toByteArray();
        var v = getValue(k);
        var builder = Types.ResponseQuery.newBuilder();
        if (v == null) {
            builder.setLog("does not exist");
        } else {
            builder.setLog("exists");
            builder.setKey(ByteString.copyFrom(k));
            builder.setValue(ByteString.copyFrom(v));
        }
        responseObserver.onNext(builder.build());
        responseObserver.onCompleted();
    }

    private byte[] getValue(byte[] k) {
        byte[] ret = null;
        try {
            String s = new String(k,StandardCharsets.UTF_8);
            Statement statement = conn.createStatement();
            ResultSet resultSet = statement.executeQuery(s);
            if(resultSet.next()){
                // Returns the first rollNo entry
                ret = resultSet.getBytes("Name");
            }
            resultSet.close();
            statement.close();
        }catch (SQLException e){
            System.out.println(e);
        }
        return ret;
    }
}
